# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.7
#
# <auto-generated>
#
# Generated from file `devices.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Devices
_M_Devices = Ice.openModule('Devices')
__name__ = 'Devices'

if 'OvenMode' not in _M_Devices.__dict__:
    _M_Devices.OvenMode = Ice.createTempClass()
    class OvenMode(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    OvenMode.CONVECTION = OvenMode("CONVECTION", 0)
    OvenMode.ECO = OvenMode("ECO", 1)
    OvenMode.TOPHEAT = OvenMode("TOPHEAT", 2)
    OvenMode.BOTTOMHEAT = OvenMode("BOTTOMHEAT", 3)
    OvenMode.GRILL = OvenMode("GRILL", 4)
    OvenMode.DEFROST = OvenMode("DEFROST", 5)
    OvenMode.ROASTING = OvenMode("ROASTING", 6)
    OvenMode._enumerators = { 0:OvenMode.CONVECTION, 1:OvenMode.ECO, 2:OvenMode.TOPHEAT, 3:OvenMode.BOTTOMHEAT, 4:OvenMode.GRILL, 5:OvenMode.DEFROST, 6:OvenMode.ROASTING }

    _M_Devices._t_OvenMode = IcePy.defineEnum('::Devices::OvenMode', OvenMode, (), OvenMode._enumerators)

    _M_Devices.OvenMode = OvenMode
    del OvenMode

if '_t_ovenModes' not in _M_Devices.__dict__:
    _M_Devices._t_ovenModes = IcePy.defineSequence('::Devices::ovenModes', (), _M_Devices._t_OvenMode)

if 'Recipe' not in _M_Devices.__dict__:
    _M_Devices.Recipe = Ice.createTempClass()
    class Recipe(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Recipe.LEMONCAKE = Recipe("LEMONCAKE", 0)
    Recipe.CARROTCAKE = Recipe("CARROTCAKE", 1)
    Recipe.CHOCOLATECAKE = Recipe("CHOCOLATECAKE", 2)
    Recipe._enumerators = { 0:Recipe.LEMONCAKE, 1:Recipe.CARROTCAKE, 2:Recipe.CHOCOLATECAKE }

    _M_Devices._t_Recipe = IcePy.defineEnum('::Devices::Recipe', Recipe, (), Recipe._enumerators)

    _M_Devices.Recipe = Recipe
    del Recipe

if 'LightColor' not in _M_Devices.__dict__:
    _M_Devices.LightColor = Ice.createTempClass()
    class LightColor(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    LightColor.RED = LightColor("RED", 0)
    LightColor.BLUE = LightColor("BLUE", 1)
    LightColor.YELLOW = LightColor("YELLOW", 2)
    LightColor.GREEN = LightColor("GREEN", 3)
    LightColor._enumerators = { 0:LightColor.RED, 1:LightColor.BLUE, 2:LightColor.YELLOW, 3:LightColor.GREEN }

    _M_Devices._t_LightColor = IcePy.defineEnum('::Devices::LightColor', LightColor, (), LightColor._enumerators)

    _M_Devices.LightColor = LightColor
    del LightColor

if '_t_lightColors' not in _M_Devices.__dict__:
    _M_Devices._t_lightColors = IcePy.defineSequence('::Devices::lightColors', (), _M_Devices._t_LightColor)

if 'LightIntensity' not in _M_Devices.__dict__:
    _M_Devices.LightIntensity = Ice.createTempClass()
    class LightIntensity(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    LightIntensity.LOW = LightIntensity("LOW", 0)
    LightIntensity.MEDIUM = LightIntensity("MEDIUM", 1)
    LightIntensity.HIGH = LightIntensity("HIGH", 2)
    LightIntensity._enumerators = { 0:LightIntensity.LOW, 1:LightIntensity.MEDIUM, 2:LightIntensity.HIGH }

    _M_Devices._t_LightIntensity = IcePy.defineEnum('::Devices::LightIntensity', LightIntensity, (), LightIntensity._enumerators)

    _M_Devices.LightIntensity = LightIntensity
    del LightIntensity

if '_t_lightIntensities' not in _M_Devices.__dict__:
    _M_Devices._t_lightIntensities = IcePy.defineSequence('::Devices::lightIntensities', (), _M_Devices._t_LightIntensity)

if 'LightMode' not in _M_Devices.__dict__:
    _M_Devices.LightMode = Ice.createTempClass()
    class LightMode(object):
        def __init__(self, color=_M_Devices.LightColor.RED, intensity=_M_Devices.LightIntensity.LOW):
            self.color = color
            self.intensity = intensity

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.color)
            _h = 5 * _h + Ice.getHash(self.intensity)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Devices.LightMode):
                return NotImplemented
            else:
                if self.color is None or other.color is None:
                    if self.color != other.color:
                        return (-1 if self.color is None else 1)
                else:
                    if self.color < other.color:
                        return -1
                    elif self.color > other.color:
                        return 1
                if self.intensity is None or other.intensity is None:
                    if self.intensity != other.intensity:
                        return (-1 if self.intensity is None else 1)
                else:
                    if self.intensity < other.intensity:
                        return -1
                    elif self.intensity > other.intensity:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_LightMode)

        __repr__ = __str__

    _M_Devices._t_LightMode = IcePy.defineStruct('::Devices::LightMode', LightMode, (), (
        ('color', (), _M_Devices._t_LightColor),
        ('intensity', (), _M_Devices._t_LightIntensity)
    ))

    _M_Devices.LightMode = LightMode
    del LightMode

if '_t_lightModes' not in _M_Devices.__dict__:
    _M_Devices._t_lightModes = IcePy.defineSequence('::Devices::lightModes', (), _M_Devices._t_LightMode)

if 'Range' not in _M_Devices.__dict__:
    _M_Devices.Range = Ice.createTempClass()
    class Range(object):
        def __init__(self, min=0, max=0):
            self.min = min
            self.max = max

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.min)
            _h = 5 * _h + Ice.getHash(self.max)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Devices.Range):
                return NotImplemented
            else:
                if self.min is None or other.min is None:
                    if self.min != other.min:
                        return (-1 if self.min is None else 1)
                else:
                    if self.min < other.min:
                        return -1
                    elif self.min > other.min:
                        return 1
                if self.max is None or other.max is None:
                    if self.max != other.max:
                        return (-1 if self.max is None else 1)
                else:
                    if self.max < other.max:
                        return -1
                    elif self.max > other.max:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_Range)

        __repr__ = __str__

    _M_Devices._t_Range = IcePy.defineStruct('::Devices::Range', Range, (), (
        ('min', (), IcePy._t_short),
        ('max', (), IcePy._t_short)
    ))

    _M_Devices.Range = Range
    del Range

if 'UnknownOvenModeException' not in _M_Devices.__dict__:
    _M_Devices.UnknownOvenModeException = Ice.createTempClass()
    class UnknownOvenModeException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Devices::UnknownOvenModeException'

    _M_Devices._t_UnknownOvenModeException = IcePy.defineException('::Devices::UnknownOvenModeException', UnknownOvenModeException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    UnknownOvenModeException._ice_type = _M_Devices._t_UnknownOvenModeException

    _M_Devices.UnknownOvenModeException = UnknownOvenModeException
    del UnknownOvenModeException

if 'UnknownRecipeException' not in _M_Devices.__dict__:
    _M_Devices.UnknownRecipeException = Ice.createTempClass()
    class UnknownRecipeException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Devices::UnknownRecipeException'

    _M_Devices._t_UnknownRecipeException = IcePy.defineException('::Devices::UnknownRecipeException', UnknownRecipeException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    UnknownRecipeException._ice_type = _M_Devices._t_UnknownRecipeException

    _M_Devices.UnknownRecipeException = UnknownRecipeException
    del UnknownRecipeException

if 'UnknownLightColor' not in _M_Devices.__dict__:
    _M_Devices.UnknownLightColor = Ice.createTempClass()
    class UnknownLightColor(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Devices::UnknownLightColor'

    _M_Devices._t_UnknownLightColor = IcePy.defineException('::Devices::UnknownLightColor', UnknownLightColor, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    UnknownLightColor._ice_type = _M_Devices._t_UnknownLightColor

    _M_Devices.UnknownLightColor = UnknownLightColor
    del UnknownLightColor

if 'UnknownLightIntensity' not in _M_Devices.__dict__:
    _M_Devices.UnknownLightIntensity = Ice.createTempClass()
    class UnknownLightIntensity(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Devices::UnknownLightIntensity'

    _M_Devices._t_UnknownLightIntensity = IcePy.defineException('::Devices::UnknownLightIntensity', UnknownLightIntensity, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    UnknownLightIntensity._ice_type = _M_Devices._t_UnknownLightIntensity

    _M_Devices.UnknownLightIntensity = UnknownLightIntensity
    del UnknownLightIntensity

if 'OutOfRangeException' not in _M_Devices.__dict__:
    _M_Devices.OutOfRangeException = Ice.createTempClass()
    class OutOfRangeException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Devices::OutOfRangeException'

    _M_Devices._t_OutOfRangeException = IcePy.defineException('::Devices::OutOfRangeException', OutOfRangeException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    OutOfRangeException._ice_type = _M_Devices._t_OutOfRangeException

    _M_Devices.OutOfRangeException = OutOfRangeException
    del OutOfRangeException

if 'Device' not in _M_Devices.__dict__:
    _M_Devices.Device = Ice.createTempClass()
    class Device(Ice.Value):
        def __init__(self, name='', type=''):
            self.name = name
            self.type = type

        def ice_id(self):
            return '::Devices::Device'

        @staticmethod
        def ice_staticId():
            return '::Devices::Device'

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_Device)

        __repr__ = __str__

    _M_Devices._t_Device = IcePy.defineValue('::Devices::Device', Device, -1, (), False, False, None, (
        ('name', (), IcePy._t_string, False, 0),
        ('type', (), IcePy._t_string, False, 0)
    ))
    Device._ice_type = _M_Devices._t_Device

    _M_Devices.Device = Device
    del Device

_M_Devices._t_IDevice = IcePy.defineValue('::Devices::IDevice', Ice.Value, -1, (), False, True, None, ())

if 'IDevicePrx' not in _M_Devices.__dict__:
    _M_Devices.IDevicePrx = Ice.createTempClass()
    class IDevicePrx(Ice.ObjectPrx):

        def getDeviceInfo(self, context=None):
            return _M_Devices.IDevice._op_getDeviceInfo.invoke(self, ((), context))

        def getDeviceInfoAsync(self, context=None):
            return _M_Devices.IDevice._op_getDeviceInfo.invokeAsync(self, ((), context))

        def begin_getDeviceInfo(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Devices.IDevice._op_getDeviceInfo.begin(self, ((), _response, _ex, _sent, context))

        def end_getDeviceInfo(self, _r):
            return _M_Devices.IDevice._op_getDeviceInfo.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Devices.IDevicePrx.ice_checkedCast(proxy, '::Devices::IDevice', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Devices.IDevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Devices::IDevice'
    _M_Devices._t_IDevicePrx = IcePy.defineProxy('::Devices::IDevice', IDevicePrx)

    _M_Devices.IDevicePrx = IDevicePrx
    del IDevicePrx

    _M_Devices.IDevice = Ice.createTempClass()
    class IDevice(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Devices::IDevice', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Devices::IDevice'

        @staticmethod
        def ice_staticId():
            return '::Devices::IDevice'

        def getDeviceInfo(self, current=None):
            raise NotImplementedError("servant method 'getDeviceInfo' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_IDeviceDisp)

        __repr__ = __str__

    _M_Devices._t_IDeviceDisp = IcePy.defineClass('::Devices::IDevice', IDevice, (), None, ())
    IDevice._ice_type = _M_Devices._t_IDeviceDisp

    IDevice._op_getDeviceInfo = IcePy.Operation('getDeviceInfo', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Devices.IDevice = IDevice
    del IDevice

if 'Oven' not in _M_Devices.__dict__:
    _M_Devices.Oven = Ice.createTempClass()
    class Oven(_M_Devices.Device):
        def __init__(self, name='', type='', modes=None, temperatureRange=Ice._struct_marker, minutesRange=Ice._struct_marker):
            _M_Devices.Device.__init__(self, name, type)
            self.modes = modes
            if temperatureRange is Ice._struct_marker:
                self.temperatureRange = _M_Devices.Range()
            else:
                self.temperatureRange = temperatureRange
            if minutesRange is Ice._struct_marker:
                self.minutesRange = _M_Devices.Range()
            else:
                self.minutesRange = minutesRange

        def ice_id(self):
            return '::Devices::Oven'

        @staticmethod
        def ice_staticId():
            return '::Devices::Oven'

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_Oven)

        __repr__ = __str__

    _M_Devices._t_Oven = IcePy.defineValue('::Devices::Oven', Oven, -1, (), False, False, _M_Devices._t_Device, (
        ('modes', (), _M_Devices._t_ovenModes, False, 0),
        ('temperatureRange', (), _M_Devices._t_Range, False, 0),
        ('minutesRange', (), _M_Devices._t_Range, False, 0)
    ))
    Oven._ice_type = _M_Devices._t_Oven

    _M_Devices.Oven = Oven
    del Oven

_M_Devices._t_IOven = IcePy.defineValue('::Devices::IOven', Ice.Value, -1, (), False, True, None, ())

if 'IOvenPrx' not in _M_Devices.__dict__:
    _M_Devices.IOvenPrx = Ice.createTempClass()
    class IOvenPrx(_M_Devices.IDevicePrx):

        def startOven(self, mode, minutes, temperature, context=None):
            return _M_Devices.IOven._op_startOven.invoke(self, ((mode, minutes, temperature), context))

        def startOvenAsync(self, mode, minutes, temperature, context=None):
            return _M_Devices.IOven._op_startOven.invokeAsync(self, ((mode, minutes, temperature), context))

        def begin_startOven(self, mode, minutes, temperature, _response=None, _ex=None, _sent=None, context=None):
            return _M_Devices.IOven._op_startOven.begin(self, ((mode, minutes, temperature), _response, _ex, _sent, context))

        def end_startOven(self, _r):
            return _M_Devices.IOven._op_startOven.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Devices.IOvenPrx.ice_checkedCast(proxy, '::Devices::IOven', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Devices.IOvenPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Devices::IOven'
    _M_Devices._t_IOvenPrx = IcePy.defineProxy('::Devices::IOven', IOvenPrx)

    _M_Devices.IOvenPrx = IOvenPrx
    del IOvenPrx

    _M_Devices.IOven = Ice.createTempClass()
    class IOven(_M_Devices.IDevice):

        def ice_ids(self, current=None):
            return ('::Devices::IDevice', '::Devices::IOven', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Devices::IOven'

        @staticmethod
        def ice_staticId():
            return '::Devices::IOven'

        def startOven(self, mode, minutes, temperature, current=None):
            raise NotImplementedError("servant method 'startOven' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_IOvenDisp)

        __repr__ = __str__

    _M_Devices._t_IOvenDisp = IcePy.defineClass('::Devices::IOven', IOven, (), None, (_M_Devices._t_IDeviceDisp,))
    IOven._ice_type = _M_Devices._t_IOvenDisp

    IOven._op_startOven = IcePy.Operation('startOven', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Devices._t_OvenMode, False, 0), ((), IcePy._t_short, False, 0), ((), IcePy._t_short, False, 0)), (), ((), IcePy._t_string, False, 0), (_M_Devices._t_UnknownOvenModeException, _M_Devices._t_OutOfRangeException))

    _M_Devices.IOven = IOven
    del IOven

_M_Devices._t_IProOven = IcePy.defineValue('::Devices::IProOven', Ice.Value, -1, (), False, True, None, ())

if 'IProOvenPrx' not in _M_Devices.__dict__:
    _M_Devices.IProOvenPrx = Ice.createTempClass()
    class IProOvenPrx(_M_Devices.IOvenPrx):

        def displayRecipe(self, recipe, context=None):
            return _M_Devices.IProOven._op_displayRecipe.invoke(self, ((recipe, ), context))

        def displayRecipeAsync(self, recipe, context=None):
            return _M_Devices.IProOven._op_displayRecipe.invokeAsync(self, ((recipe, ), context))

        def begin_displayRecipe(self, recipe, _response=None, _ex=None, _sent=None, context=None):
            return _M_Devices.IProOven._op_displayRecipe.begin(self, ((recipe, ), _response, _ex, _sent, context))

        def end_displayRecipe(self, _r):
            return _M_Devices.IProOven._op_displayRecipe.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Devices.IProOvenPrx.ice_checkedCast(proxy, '::Devices::IProOven', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Devices.IProOvenPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Devices::IProOven'
    _M_Devices._t_IProOvenPrx = IcePy.defineProxy('::Devices::IProOven', IProOvenPrx)

    _M_Devices.IProOvenPrx = IProOvenPrx
    del IProOvenPrx

    _M_Devices.IProOven = Ice.createTempClass()
    class IProOven(_M_Devices.IOven):

        def ice_ids(self, current=None):
            return ('::Devices::IDevice', '::Devices::IOven', '::Devices::IProOven', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Devices::IProOven'

        @staticmethod
        def ice_staticId():
            return '::Devices::IProOven'

        def displayRecipe(self, recipe, current=None):
            raise NotImplementedError("servant method 'displayRecipe' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_IProOvenDisp)

        __repr__ = __str__

    _M_Devices._t_IProOvenDisp = IcePy.defineClass('::Devices::IProOven', IProOven, (), None, (_M_Devices._t_IOvenDisp,))
    IProOven._ice_type = _M_Devices._t_IProOvenDisp

    IProOven._op_displayRecipe = IcePy.Operation('displayRecipe', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Devices._t_Recipe, False, 0),), (), ((), IcePy._t_string, False, 0), (_M_Devices._t_UnknownRecipeException,))

    _M_Devices.IProOven = IProOven
    del IProOven

if 'Light' not in _M_Devices.__dict__:
    _M_Devices.Light = Ice.createTempClass()
    class Light(_M_Devices.Device):
        def __init__(self, name='', type='', mode=Ice._struct_marker):
            _M_Devices.Device.__init__(self, name, type)
            if mode is Ice._struct_marker:
                self.mode = _M_Devices.LightMode()
            else:
                self.mode = mode

        def ice_id(self):
            return '::Devices::Light'

        @staticmethod
        def ice_staticId():
            return '::Devices::Light'

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_Light)

        __repr__ = __str__

    _M_Devices._t_Light = IcePy.defineValue('::Devices::Light', Light, -1, (), False, False, _M_Devices._t_Device, (('mode', (), _M_Devices._t_LightMode, False, 0),))
    Light._ice_type = _M_Devices._t_Light

    _M_Devices.Light = Light
    del Light

_M_Devices._t_ILight = IcePy.defineValue('::Devices::ILight', Ice.Value, -1, (), False, True, None, ())

if 'ILightPrx' not in _M_Devices.__dict__:
    _M_Devices.ILightPrx = Ice.createTempClass()
    class ILightPrx(_M_Devices.IDevicePrx):

        def toggleLightColor(self, context=None):
            return _M_Devices.ILight._op_toggleLightColor.invoke(self, ((), context))

        def toggleLightColorAsync(self, context=None):
            return _M_Devices.ILight._op_toggleLightColor.invokeAsync(self, ((), context))

        def begin_toggleLightColor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Devices.ILight._op_toggleLightColor.begin(self, ((), _response, _ex, _sent, context))

        def end_toggleLightColor(self, _r):
            return _M_Devices.ILight._op_toggleLightColor.end(self, _r)

        def toggleLightIntensity(self, context=None):
            return _M_Devices.ILight._op_toggleLightIntensity.invoke(self, ((), context))

        def toggleLightIntensityAsync(self, context=None):
            return _M_Devices.ILight._op_toggleLightIntensity.invokeAsync(self, ((), context))

        def begin_toggleLightIntensity(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Devices.ILight._op_toggleLightIntensity.begin(self, ((), _response, _ex, _sent, context))

        def end_toggleLightIntensity(self, _r):
            return _M_Devices.ILight._op_toggleLightIntensity.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Devices.ILightPrx.ice_checkedCast(proxy, '::Devices::ILight', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Devices.ILightPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Devices::ILight'
    _M_Devices._t_ILightPrx = IcePy.defineProxy('::Devices::ILight', ILightPrx)

    _M_Devices.ILightPrx = ILightPrx
    del ILightPrx

    _M_Devices.ILight = Ice.createTempClass()
    class ILight(_M_Devices.IDevice):

        def ice_ids(self, current=None):
            return ('::Devices::IDevice', '::Devices::ILight', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Devices::ILight'

        @staticmethod
        def ice_staticId():
            return '::Devices::ILight'

        def toggleLightColor(self, current=None):
            raise NotImplementedError("servant method 'toggleLightColor' not implemented")

        def toggleLightIntensity(self, current=None):
            raise NotImplementedError("servant method 'toggleLightIntensity' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_ILightDisp)

        __repr__ = __str__

    _M_Devices._t_ILightDisp = IcePy.defineClass('::Devices::ILight', ILight, (), None, (_M_Devices._t_IDeviceDisp,))
    ILight._ice_type = _M_Devices._t_ILightDisp

    ILight._op_toggleLightColor = IcePy.Operation('toggleLightColor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    ILight._op_toggleLightIntensity = IcePy.Operation('toggleLightIntensity', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Devices.ILight = ILight
    del ILight

_M_Devices._t_IProLight = IcePy.defineValue('::Devices::IProLight', Ice.Value, -1, (), False, True, None, ())

if 'IProLightPrx' not in _M_Devices.__dict__:
    _M_Devices.IProLightPrx = Ice.createTempClass()
    class IProLightPrx(_M_Devices.ILightPrx):

        def setLightMode(self, lightColor, lightIntensity, context=None):
            return _M_Devices.IProLight._op_setLightMode.invoke(self, ((lightColor, lightIntensity), context))

        def setLightModeAsync(self, lightColor, lightIntensity, context=None):
            return _M_Devices.IProLight._op_setLightMode.invokeAsync(self, ((lightColor, lightIntensity), context))

        def begin_setLightMode(self, lightColor, lightIntensity, _response=None, _ex=None, _sent=None, context=None):
            return _M_Devices.IProLight._op_setLightMode.begin(self, ((lightColor, lightIntensity), _response, _ex, _sent, context))

        def end_setLightMode(self, _r):
            return _M_Devices.IProLight._op_setLightMode.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Devices.IProLightPrx.ice_checkedCast(proxy, '::Devices::IProLight', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Devices.IProLightPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Devices::IProLight'
    _M_Devices._t_IProLightPrx = IcePy.defineProxy('::Devices::IProLight', IProLightPrx)

    _M_Devices.IProLightPrx = IProLightPrx
    del IProLightPrx

    _M_Devices.IProLight = Ice.createTempClass()
    class IProLight(_M_Devices.ILight):

        def ice_ids(self, current=None):
            return ('::Devices::IDevice', '::Devices::ILight', '::Devices::IProLight', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Devices::IProLight'

        @staticmethod
        def ice_staticId():
            return '::Devices::IProLight'

        def setLightMode(self, lightColor, lightIntensity, current=None):
            raise NotImplementedError("servant method 'setLightMode' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Devices._t_IProLightDisp)

        __repr__ = __str__

    _M_Devices._t_IProLightDisp = IcePy.defineClass('::Devices::IProLight', IProLight, (), None, (_M_Devices._t_ILightDisp,))
    IProLight._ice_type = _M_Devices._t_IProLightDisp

    IProLight._op_setLightMode = IcePy.Operation('setLightMode', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Devices._t_LightColor, False, 0), ((), _M_Devices._t_LightIntensity, False, 0)), (), ((), IcePy._t_string, False, 0), (_M_Devices._t_UnknownLightColor, _M_Devices._t_UnknownLightIntensity))

    _M_Devices.IProLight = IProLight
    del IProLight

# End of module Devices
